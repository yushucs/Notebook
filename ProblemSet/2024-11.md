判断二叉树是否是平衡二叉树

设计思想：

递归计算高度并判断平衡性，通过引用变量`height`返回子树高度，避免重复计算。

【算法描述】

```c++
#include <cmath>
#include <algorithm>

typedef struct BiTNode {
    int data;
    struct BiTNode* lchild;
    struct BiTNode* rchild;
} BiTNode, *BiTree;

// 辅助函数：同时计算高度和判断平衡性
bool isBalancedHelper(BiTree T, int& height) {
    if (T == NULL) {
        height = 0;  // 空树高度为 0
        return true; // 空树是平衡的
    }

    int leftHeight = 0, rightHeight = 0;

    // 判断左子树是否平衡并计算其高度
    if (!isBalancedHelper(T->lchild, leftHeight)) {
        return false;
    }

    // 判断右子树是否平衡并计算其高度
    if (!isBalancedHelper(T->rchild, rightHeight)) {
        return false;
    }

    // 判断当前节点是否平衡
    if (abs(leftHeight - rightHeight) > 1) {
        return false;
    }

    // 当前节点的高度为左右子树最大高度加 1
    height = std::max(leftHeight, rightHeight) + 1;

    return true;
}

// 主函数：判断二叉树是否为平衡二叉树
bool isBalanceTree(BiTree T) {
    int height = 0; // 初始化高度
    return isBalancedHelper(T, height);
}

```

【算法分析】

- 时间复杂度

每个节点只被访问一次，因此时间复杂度为 O(n)，其中 n 是二叉树的节点数。

- 空间复杂度

递归栈的深度为树的高度，最坏情况下（如链表形式的二叉树）为 O(n)，平均情况下为O(logn)。



---



设计一算法，使得在尽可能少的时间内重排数组，将所有取负值的关键字放在所有取非负值的关键字之前。

算法思想：双指针 `low` 和 `high` 分别从数组的两端向中间移动，保证 `low` 指向非负值，`high` 指向负值，然后交换它们。

【算法描述】

```c++
#include <iostream>

using namespace std;

void Solution(int arr[], int length)
{
    if (length <= 1)
        return;

    int low = 0, high = length - 1;

    while (low < high)
    {
        while (low < high && arr[low] < 0)
            ++low;
        while (low < high && arr[high] >= 0)
            --high;
        if (low < high)
            std::swap(arr[low], arr[high]);
    }
}

int main()
{
    int arr[] = {2, -3, 5, -7, -6, 1, 0, -4};
    int length = sizeof(arr) / sizeof(arr[0]);

    Solution(arr, length);

    for (int i = 0; i < length; ++i)
    {
        std::cout << arr[i] << " ";
    }
    return 0;
}
```

【算法分析】

- 时间复杂度

双指针每次移动一位，最多移动 n 次，因此时间复杂度为 O(n)。

- 空间复杂度

使用原地交换，不需要额外空间，空间复杂度为 O(1)。



---

请设计一个算法，将有n个元素的数组A中的元素A[0]至A[n-1]循环右移k位，并要求只用一个元素大小的附加存储，元素移动或交换次数为O(n)。

【算法思想】

先将线性表整体逆置，再分别逆置其前k位、后n-k位。

```c++
// 反转数组中的一段 [from, to]
void reverse(int arr[], int from, int to) 
{
    int temp;
    for (int i = 0; i < (to - from + 1) / 2; ++i)
    {
        temp = arr[from + i];
        arr[from + i] = arr[to - i];
        arr[to - i] = temp;
    }
}

// 循环右移 k 位
void reverseList(int arr[], int n, int k)
{
    if (n == 0 || k <= 0) return; // 边界条件

    // 步骤 1：整体反转
    reverse(arr, 0, n - 1);

    // 步骤 2：反转前 k 位
    reverse(arr, 0, k - 1);

    // 步骤 3：反转后 n-k 位
    reverse(arr, k, n - 1);
}
```

【算法分析】

- 时间复杂度

反转操作：每次反转的复杂度为 O(m)（m 为反转区间长度）。

总时间复杂度：O(n)。

- 空间复杂度

只用一个元素大小的附加存储，空间复杂度位：O(1)。
