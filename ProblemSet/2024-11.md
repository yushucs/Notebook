判断二叉树是否是平衡二叉树

设计思想：

递归计算高度并判断平衡性，通过引用变量`height`返回子树高度，避免重复计算。

【算法描述】

```c++
#include <cmath>
#include <algorithm>

typedef struct BiTNode {
    int data;
    struct BiTNode* lchild;
    struct BiTNode* rchild;
} BiTNode, *BiTree;

// 辅助函数：同时计算高度和判断平衡性
bool isBalancedHelper(BiTree T, int& height) {
    if (T == NULL) {
        height = 0;  // 空树高度为 0
        return true; // 空树是平衡的
    }

    int leftHeight = 0, rightHeight = 0;

    // 判断左子树是否平衡并计算其高度
    if (!isBalancedHelper(T->lchild, leftHeight)) {
        return false;
    }

    // 判断右子树是否平衡并计算其高度
    if (!isBalancedHelper(T->rchild, rightHeight)) {
        return false;
    }

    // 判断当前节点是否平衡
    if (abs(leftHeight - rightHeight) > 1) {
        return false;
    }

    // 当前节点的高度为左右子树最大高度加 1
    height = std::max(leftHeight, rightHeight) + 1;

    return true;
}

// 主函数：判断二叉树是否为平衡二叉树
bool isBalanceTree(BiTree T) {
    int height = 0; // 初始化高度
    return isBalancedHelper(T, height);
}

```

【算法分析】

时间复杂度：

每个节点只被访问一次，因此时间复杂度为 O(n)，其中 n 是二叉树的节点数。

空间复杂度：

递归栈的深度为树的高度，最坏情况下（如链表形式的二叉树）为 O(n)，平均情况下为O(logn)。