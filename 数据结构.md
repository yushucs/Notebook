# 树和二叉树

树结构是一类重要的非线性数据结构，是以分支关系定义的层次结构。

## 树和二叉树的定义

**树**（Tree）是n（n≥0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树T：（1）有且仅有一个称之为根的结点；（2）除根结点以外的其余结点可分为m（m>0）个互不相交的有限集T1,T2, …, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

> 树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。

**结点**：树中的一个独立单元。

**结点的度**：结点拥有的子树数称为结点的度。

**叶子**：度为0的结点称为叶子或终端结点。

**非终端结点**：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

**双亲和孩子**：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。

**兄弟**：同一个双亲的孩子之间互称兄弟。

**祖先**：从根到该结点所经分支上的所有结点。

**子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。

**层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

**堂兄弟**：双亲在同一层的结点互为堂兄弟。

**树的深度**：树中结点的最大层次称为树的深度或高度。

**有序树和无序树**：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。

**森林**：是m（m≥0）棵互不相交的树的集合。

---

**二叉树**（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n=0）；或为非空树，对于非空树T：

（1）有且仅有一个称之为根的结点；

（2）除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。

> 二叉树中不存在度大于2的结点；
>
> 二叉树的子树有左右之分，其次序不能任意颠倒，是有序树。

## 二叉树的性质

**性质1** 在二叉树的第i层上至多有$2^{i−1}$个结点（i≥1）。

**性质2** 深度为k的二叉树至多有$2^k−1$个结点（k≥1）。

**性质3** 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

**满二叉树**：深度为k且含有$2^k−1$个结点的二叉树。



# 图

在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

## 图的定义和基本术语

**图**（Graph）G由两个集合V和E组成，记为G=(V, E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。

**无向图和有向图**：对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。

**子图**：假设有两个图G=(V, E)和G′=(V′, E′)，如果V′∈V且E′∈E，则称G′为G的子图。

**无向完全图**：若具有n(n−1)/2条边，则称为无向完全图。

**有向完全图**：若具有n(n−1)条弧，则称为有向完全图。

**稀疏图和稠密图**：有很少条边或弧（如e<nlog2n）的图称为稀疏图，反之称为稠密图。

**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

**邻接点**：对于无向图G，如果图的边(v, v′)∈E，则称顶点v和v′互为邻接点，即v和v′**相邻接**。边(v, v′)**依附于**顶点v和v′，或者说边(v, v′)与顶点v和v′**相关联**。

**度、入度和出度**：顶点v的度是指和v相关联的边的数目，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v)。顶点v的度为TD(v)=ID(v)+OD(v)。

**路径**：在无向图G中，从顶点v到顶点v′的路径是一个顶点序列。

**路径长度**：路径长度是一条路径上经过的边或弧的数目。

**回路或环**：第一个顶点和最后一个顶点相同的路径称为回路或环。

**简单路径、简单回路或简单环**：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

**连通、连通图**：在无向图G中，如果从顶点v到顶点v′有路径，则称v和v′是连通的。如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图。

**连通分量**：指的是无向图中的**极大连通子图**。

**强连通图和强连通分量**：在有向图G中，如果对于每一对vi,vj∈V,vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。

**连通图的生成树**：一个**极小连通子图**，它含有图中全部顶点，但只有足以构成一棵树的n−1条边，这样的连通子图称为连通图的生成树。

> 一棵有n个顶点的生成树有且仅有n−1条边。如果一个图有n个顶点和小于n−1条边，则是非连通图。如果它多于n−1条边，则一定有环。但是，有n−1条边的图不一定是生成树。

**有向树和生成森林**：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。



# 查找



## 查找的基本概念

**查找表**：查找表是由同一类型的数据元素（或记录）构成的集合。

**关键字**：关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字**（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

**查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功，**此时查找的结果可给出一个“空”记录或“空”指针。

**动态查找表和静态查找表**：若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为动态**查找表**，否则称之为**静态查找表**。

> 换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。

**平均查找长度**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。

对于含有n个记录的表，查找成功时的平均查找长度为
$$
ASL = \sum_{i=1}^{n}{p_ic_i} \\
And\ \ \sum_{i=1}^{n}p_i = 1
$$
其中，Pi为查找表中第i个记录的概率；Ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。显然，Ci随查找过程不同而不同。

> 由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能。



## 线性表的查找



### 顺序查找

**顺序查找**（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

```c++
int Search_Seq(SSTable ST,KeyType key)
{//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
   ST.R[0].key=key;                                             //“哨兵”
   for(i=ST.length;ST.R[i].key!=key;--i);                       //从后往前找
   return i;
}
```

**算法分析**：

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i} = \frac{n+1}{2}
$$
**时间复杂度**：O(n)。

**顺序查找的优点**：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。

**顺序查找的缺点**：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。



### 折半查找

**折半查找**（Binary Search）的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

```c++
int Search_Bin(SSTable ST,KeyType key)
{//在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0 
   low=1;high=ST.length;                       //置查找区间初值 
   while(low<=high) 
   { 
      mid=(low+high)/2; 
      if(key==ST.R[mid].key) return mid;       //找到待查元素 
      else if(key<ST.R[mid].key) high=mid-1;   //继续在前一子表进行查找 
      else low=mid+1;                          //继续在后一子表进行查找 
   }                                           //while 
   return 0;                                   //表中不存在待查元素 
}
```

> 注意：循环执行的条件是low<=high，而不是low<high，因为low=high时，查找区间还有最后一个结点，还要进一步比较。

**算法分析**：

折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的**判定树**。

折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为$$\lfloor log_{2}{n} \rfloor + 1$$。

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i \cdot 2^{i-1}} = \frac{n+1}{n} log_{2}{(n+1)} - 1 \\
n较大时,\ \ \ ASL_{成功} = log_{2}{(n+1)} - 1
$$
**时间复杂度**：O(log2n )。

**折半查找的优点**：比较次数少，查找效率高。

**折半查找的缺点**：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。



### 分块查找

**分块查找**（Blocking Search）又称**索引顺序查找**