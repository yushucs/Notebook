[树和二叉树](#树和二叉树)

[图](#图)

[查找](#查找)



# 树和二叉树

树结构是一类重要的非线性数据结构，是以分支关系定义的层次结构。

## 树和二叉树的定义

**树**（Tree）是n（n≥0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树T：（1）有且仅有一个称之为根的结点；（2）除根结点以外的其余结点可分为m（m>0）个互不相交的有限集T1,T2, …, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

> 树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。

**结点**：树中的一个独立单元。

**结点的度**：结点拥有的子树数称为结点的度。

**叶子**：度为0的结点称为叶子或终端结点。

**非终端结点**：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

**双亲和孩子**：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。

**兄弟**：同一个双亲的孩子之间互称兄弟。

**祖先**：从根到该结点所经分支上的所有结点。

**子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。

**层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

**堂兄弟**：双亲在同一层的结点互为堂兄弟。

**树的深度**：树中结点的最大层次称为树的深度或高度。

**有序树和无序树**：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。

**森林**：是m（m≥0）棵互不相交的树的集合。

---

**二叉树**（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n=0）；或为非空树，对于非空树T：

（1）有且仅有一个称之为根的结点；

（2）除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。

> 二叉树中不存在度大于2的结点；
>
> 二叉树的子树有左右之分，其次序不能任意颠倒，是有序树。

## 二叉树的性质

**性质1** 在二叉树的第i层上至多有$2^{i−1}$个结点（i≥1）。

**性质2** 深度为k的二叉树至多有$2^k−1$个结点（k≥1）。

**性质3** 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

**满二叉树**：深度为k且含有$2^k−1$个结点的二叉树。



# 图

在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

## 图的定义和基本术语

**图**（Graph）G由两个集合V和E组成，记为G=(V, E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。

**无向图和有向图**：对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。

**子图**：假设有两个图G=(V, E)和G′=(V′, E′)，如果V′∈V且E′∈E，则称G′为G的子图。

**无向完全图**：若具有n(n−1)/2条边，则称为无向完全图。

**有向完全图**：若具有n(n−1)条弧，则称为有向完全图。

**稀疏图和稠密图**：有很少条边或弧（如e<nlog2n）的图称为稀疏图，反之称为稠密图。

**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

**邻接点**：对于无向图G，如果图的边(v, v′)∈E，则称顶点v和v′互为邻接点，即v和v′**相邻接**。边(v, v′)**依附于**顶点v和v′，或者说边(v, v′)与顶点v和v′**相关联**。

**度、入度和出度**：顶点v的度是指和v相关联的边的数目，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v)。顶点v的度为TD(v)=ID(v)+OD(v)。

**路径**：在无向图G中，从顶点v到顶点v′的路径是一个顶点序列。

**路径长度**：路径长度是一条路径上经过的边或弧的数目。

**回路或环**：第一个顶点和最后一个顶点相同的路径称为回路或环。

**简单路径、简单回路或简单环**：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

**连通、连通图**：在无向图G中，如果从顶点v到顶点v′有路径，则称v和v′是连通的。如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图。

**连通分量**：指的是无向图中的**极大连通子图**。

**强连通图和强连通分量**：在有向图G中，如果对于每一对vi,vj∈V,vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。

**连通图的生成树**：一个**极小连通子图**，它含有图中全部顶点，但只有足以构成一棵树的n−1条边，这样的连通子图称为连通图的生成树。

> 一棵有n个顶点的生成树有且仅有n−1条边。如果一个图有n个顶点和小于n−1条边，则是非连通图。如果它多于n−1条边，则一定有环。但是，有n−1条边的图不一定是生成树。

**有向树和生成森林**：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。



# 查找

1. [查找的基本概念](##查找的基本概念)
2. [线性表的查找](##线性表的查找)
3. [树表的查找](##树表的查找)
4. [散列表的查找](##散列表的查找)



## 查找的基本概念

**查找表**：查找表是由同一类型的数据元素（或记录）构成的集合。

**关键字**：关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字**（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

**查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功，**此时查找的结果可给出一个“空”记录或“空”指针。

**动态查找表和静态查找表**：若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为**动态查找表**，否则称之为**静态查找表**。

> 换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。

**平均查找长度**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。

对于含有n个记录的表，查找成功时的平均查找长度为
$$
ASL = \sum_{i=1}^{n}{p_ic_i} \\
And\ \ \sum_{i=1}^{n}p_i = 1
$$
其中，Pi为查找表中第i个记录的概率；Ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。显然，Ci随查找过程不同而不同。

> 由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能。



## 线性表的查找



### 顺序查找

**顺序查找**（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

```c++
int Search_Seq(SSTable ST,KeyType key)
{//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
   ST.R[0].key=key;                                             //“哨兵”
   for(i=ST.length;ST.R[i].key!=key;--i);                       //从后往前找
   return i;
}
```

【算法分析】

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i} = \frac{n+1}{2}
$$
**时间复杂度**：O(n)。

**顺序查找的优点**：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。

**顺序查找的缺点**：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。



### 折半查找

**折半查找**（Binary Search）的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

```c++
int Search_Bin(SSTable ST,KeyType key)
{//在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0 
   low=1;high=ST.length;                       //置查找区间初值 
   while(low<=high) 
   { 
      mid=(low+high)/2; 
      if(key==ST.R[mid].key) return mid;       //找到待查元素 
      else if(key<ST.R[mid].key) high=mid-1;   //继续在前一子表进行查找 
      else low=mid+1;                          //继续在后一子表进行查找 
   }                                           //while 
   return 0;                                   //表中不存在待查元素 
}
```

> 注意：循环执行的条件是low<=high，而不是low<high，因为low=high时，查找区间还有最后一个结点，还要进一步比较。

【算法分析】

折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的**判定树**。

折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为$$\lfloor log_{2}{n} \rfloor + 1$$。

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i \cdot 2^{i-1}} = \frac{n+1}{n} log_{2}{(n+1)} - 1 \\
n较大时,\ \ \ ASL_{成功} = log_{2}{(n+1)} - 1
$$
**时间复杂度**：O(log2n )。

**折半查找的优点**：比较次数少，查找效率高。

**折半查找的缺点**：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。



### 分块查找

**分块查找**（Blocking Search）又称**索引顺序查找**



## 树表的查找

线性表的查找更适用于静态查找表，若要对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为**树表**。

### 二叉排序树

**二叉排序树**（Binary Sort Tree）又称**二叉查找树**，它是一种对排序和查找都很有用的特殊二叉树。

#### 二叉排序树的定义

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

（1）若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）它的左、右子树也分别为二叉排序树。

> 中序遍历一棵二叉树时可以得到一个结点值递增的有序序列。

```c++
//- - - - -二叉排序树的二叉链表存储表示- - - - -
typedef struct
{
   KeyType key;                                 //关键字项
   InfoType otherinfo;                          //其他数据项
}ElemType;                                      //每个结点的数据域的类型
typedef struct BSTNode
{
   ElemType data;                               //每个结点的数据域包括关键字项和其他数据项
   struct BSTNode *lchild,*rchild;              //左右孩子指针
}BSTNode,*BSTree;
```

#### 二叉排序树的查找

在二叉排序树上进行查找和折半查找类似。

**二叉排序树的递归查找**

【算法步骤】

① 若二叉排序树为空，则查找失败，返回空指针。

② 若二叉排序树非空，将给定值key与根结点的关键字T->data.key进行比较：

- 若key等于T->data.key，则查找成功，返回根结点地址；
- 若key小于T->data.key，则递归查找左子树；
- 若key大于T->data.key，则递归查找右子树。

```c++
BSTree SearchBST(BSTree T,KeyType key)
{//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素
 //若查找成功，则返回指向该数据元素结点的指针，否则返回空指针
   if((!T)||key==T->data.key) return T;                      //查找结束
   else if(key<T->data.key) return SearchBST(T->lchild,key); //在左子树中继续查找
   else return SearchBST(T->rchild,key);                     //在右子树中继续查找
}
```

【算法分析】

在二叉排序树上查找其关键字等于给定值的结点的过程，恰是走了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加1（或结点所在层次数）。

然而，折半查找长度为n的顺序表的判定树是唯一的，而含有n个结点的二叉排序树却不唯一。

因此，含有n个结点的二叉排序树的平均查找长度和树的形态有关。当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树。树的深度为n，其平均查找长度为[插图]（和顺序查找相同），这是最差的情况。显然，最好的情况是，二叉排序树的形态和折半查找的判定树相似，其平均查找长度和log2n成正比。

可以证明，综合所有可能的情况，就平均而言，二叉排序树的平均查找长度仍然和log2n是同数量级的。

####  二叉排序树的插入

二叉排序树的插入操作是以查找为基础的。

【算法步骤】

① 若二叉排序树为空，则待插入结点*S作为根结点插入到空树中。

② 若二叉排序树非空，则将key与根结点的关键字T->data.key进行比较：

- 若key小于T->data.key，则将*S插入左子树；
- 若key大于T->data.key，则将*S插入右子树。

【算法描述】

```c++
void InsertBST(BSTree &T,ElemType e)
{//当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素 
   if(!T) 
   {                              //找到插入位置，递归结束 
      S=new BSTNode;              //生成新结点*S 
      S->data=e;                  //新结点*S的数据域置为e    
      S->lchild=S->rchild=NULL;   //新结点*S作为叶子结点 
      T=S;                        //把新结点*S链接到已找到的插入位置 
   } 
   else if(e.key<T->data.key)  
      InsertBST(T->lchild, e );  //将*S插入左子树 
   else if (e.key> T->data.key)  
      InsertBST(T->rchild, e);   //将*S插入右子树 
}
```

【算法分析】

二叉排序树插入的基本过程是查找，所以时间复杂度同查找一样，是O(log2n)。



#### 二叉排序树的创建

二叉排序树的创建是从空的二叉排序树开始的，每输入一个结点，经过查找操作，将新结点插入到当前二叉排序树的合适位置。

【算法步骤】

① 将二叉排序树T初始化为空树。

② 读入一个关键字为key的结点。

③ 如果读入的关键字key不是输入结束标志，则循环执行以下操作：

- 将此结点插入二叉排序树T中；
- 读入一个关键字为key的结点。

【算法描述】

```c++
void CreatBST(BSTree &T)
{//依次读入一个关键字为key的结点，将此结点插入二叉排序树T中 
   T=NULL;                  //将二叉排序树T初始化为空树 
   cin>>e;  
   while(e.key!=ENDFLAG)    //ENDFLAG为自定义常量，作为输入结束标志 
   { 
      InsertBST(T,e);       //将此结点插入二叉排序树T中 
      cin>>e;  
   }      
}
```

【算法分析】

假设有n个结点，则需要n次插入操作，而插入一个结点的算法时间复杂度为O(log2n)，所以创建二叉排序树算法的时间复杂度为O(nlog2n)。

#### 二叉排序树的删除

被删除的结点可能是二叉排序树中的任何结点，删除结点后，要根据其位置不同修改其双亲结点及相关结点的指针，以保持二叉排序树的特性。

【算法步骤】

首先从二叉排序树的根结点开始查找关键字为key的待删结点，如果树中不存在此结点，则不做任何操作；否则，假设被删结点为\*p（指向结点的指针为p），其双亲结点为\*f（指向结点的指针为f），PL和PR分别表示其左子树和右子树。

不失一般性，可设*p是*f的左孩子（右孩子情况类似）。下面分3种情况进行讨论。

（1）若\*p结点为叶子结点，即PL和PR均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。

```
f->lchild=NULL;
```

（2）若\*p结点只有左子树PL或者只有右子树PR，此时只要令PL或PR直接成为其双亲结点\*f的左子树即可。

```
f->lchild=p->lchild;（或f->lchild=p->rchild;）
```

（3）若\*p结点的左子树和右子树均不空。在删去\*p之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：

- 令`*p`的左子树为`*f`的左子树，而\*p的右子树为`*p的左子树根结点`的右子树。

```
f->lchild=p->lchild; s->rchild=p->rchild;
```

- 令`*p`的直接前驱（或直接后继）替代`*p`，然后再从二叉排序树中删去它的直接前驱（或直接后继）。

```
p->data=s->data; q->rchild=s->lchild;
```

  



### B-树



#### B-树的定义

一棵m阶的B-树，或为空树，或为满足下列特性的m叉树：

（1）树中每个结点至多有m棵子树；

（2）若根结点不是叶子结点，则至少有两棵子树；

（3）除根之外的所有非终端结点至少有$\lceil m/2 \rceil$棵子树；

（4）所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点（失败结点并不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能）；

（5）所有的非终端结点最多有m−1个关键字。

![image-20241115225527878](.\images\image-20241115225527878.png)

> 其中，Ki（i=1, …, n）为关键字，且Ki<Ki+1（i=1, …, n−1）；Pi（i=0, …,n）为指向子树根结点的指针，且指针Pi−1所指子树中所有结点的关键字均小于Ki（i=1, …, n），Pn所指子树中所有结点的关键字均大于Kn。
>
> 关键字个数取值范围：$\lceil m/2 \rceil - 1 \le n \le m -1$。

B-树具有平衡、有序、多路的特点：

1. 所有叶子结点均在同一层次，这体现出其平衡的特点。

2. 树中每个结点中的关键字都是有序的，且关键字Ki“左子树”中的关键字均小于Ki，而其“右子树”中的关键字均大于Ki，这体现出其有序的特点。

3. 除叶子结点外，有的结点中有一个关键字，两棵子树，有的结点中有两个关键字，三棵子树，这种4阶的B-树最多有三个关键字，四棵子树，这体现出其多路的特点。

#### B-树的查找









## 散列表的查找



### 散列表的基本概念

如果能在元素的存储位置和其关键字之间建立某种直接关系，那么在进行查找时，就无需做比较或做很少次的比较，按照这种关系直接由关键字找到相应的记录。这就是**散列查找法**（Hash Search）的思想，它通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。因此，**散列查找法**又叫**杂凑法**或**散列法**。

**散列函数和散列地址**：在记录的存储位置`p`和其关键字`key`之间建立一个确定的对应关系`H`，使`p=H(key)`，称这个对应关系`H`为散列函数，`p`为散列地址。

**散列表**：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录。通常散列表的存储空间是一个一维数组，散列地址是数组的下标。

**冲突和同义词**：对不同的关键字可能得到同一散列地址，即`key1≠key2`，而`H(key1)=H(key2)`，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作同义词，key1与key2互称为同义词。

### 散列函数的构造方法

1．**直接定址法**

取关键字或关键字的某个线性函数值为散列地址，即`H(key)=key`或`H(key)=a *key + b`，其中a和b为常数（这种散列函数叫做自身函数）。

直接定址法所得地址集合和关键字集合的大小相同。因此，对于不同关键字不会发生冲突，但实际中能使用这种哈希函数的情况很少。

2．**数字分析法**

如果事先知道关键字集合，且每个关键字的位数比散列表的地址码位数多，每个关键字由n位数组成，如k1，k2，…，kn，则可以从关键字中提取数字分布比较均匀的若干位作为散列地址。

数字分析法的适用情况：事先必须明确知道所有的关键字每一位上各种数字的分布情况。

3．**平方取中法**

通常在选定散列函数时不一定能知道关键字的全部情况，取其中哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，如果取关键字平方后的中间几位或其组合作为散列地址，则使随机分布的关键字得到的散列地址也是随机的，具体所取的位数由表长决定。平方取中法是一种较常用的构造散列函数的方法。

4．**折叠法**

将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址，这种方法称为折叠法。根据数位叠加的方式，可以把折叠法分为**移位叠加**和**边界叠加**两种。移位叠加是将分割后每一部分的最低位对齐，然后相加；边界叠加是将两个相邻的部分沿边界来回折叠，然后对齐相加。

折叠法的适用情况：适合于散列地址的位数较少，而关键字的位数较多，且难于直接从关键字中找到取值较分散的几位。

5．**除留余数法**

假设散列表表长为m，选择一个不大于m的数p，用p去除关键字，除后所得余数为散列地址，即`H(key)=key%p`这个方法的关键是选取适当的p，一般情况下，可以选p为小于表长的最大质数。



### 处理冲突的方法

处理冲突的方法与散列表本身的组织形式有关。按组织形式的不同，通常分两大类：**开放地址法**和**链地址法**。

1．**开放地址法**

开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字key的初始散列地址H0=H(key)发生冲突时，以H0为基础，采取合适方法计算得到另一个地址H1，如果H1仍然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk不发生冲突为止，则Hk为该记录在表中的散列地址。

这种方法在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的，所以称为开放地址法。通常把寻找“下一个”空位的过程称为探测，上述方法可用如下公式表示：
$$
H_i = (H(key) + d_i) \% m \ \ \ i = 1,2,\dots,k\ \ (k \le m-1)
$$
其中，H(key)为散列函数，m为散列表表长，di为增量序列。根据di取值的不同，可以分为以下3种探测方法:

（1）**线性探测法**
$$
d_i = 1,2,\dots,m-1
$$
这种探测方法可以将散列表假想成一个**循环表**，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后一个位置也没找到空单元，则回到表头开始继续查找，直到找到一个空位，就把此元素放入此空位中。如果找不到空位，则说明散列表已满，需要进行溢出处理。

（2）**二次探测法**
$$
d_i = 1^2, -1^2, 2^2, -2^2, \dots, k^2, -k^2 \ \ (k \le m/2)
$$
（3）**伪随机探测法**
$$
d_i = 伪随机数序列
$$
**线性探测法的优点**：只要散列表未填满，总能找到一个不发生冲突的地址。

**线性探测法的缺点**：会产生“二次聚集”现象。

**二次探测法和伪随机探测法的优点**：可以避免“二次聚集”现象。

**二次探测法和伪随机探测法的缺点**：不能保证一定找到不发生冲突的地址。

> “二次聚集”（或称作“堆积”）：在线性探测法处理冲突的过程中，两个初始散列地址不同的记录争夺同一个后继散列地址的现象，即在处理同义词的冲突过程中又添加了非同义词的冲突。

2．**链地址法**

链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有m个散列地址就有m个单链表，同时用数组HT[0…m−1]存放各个链表的头指针，凡是散列地址为i的记录都以结点方式插入到以HT[i]为头结点的单链表中。

### 散列表的查找



**散列表的存储表示**

```c++
//- - - - -开放地址法散列表的存储表示- - - - -
#define m 20                                            //散列表的表长
typedef struct{
    KeyType key;                                        //关键字项
    InfoType otherinfo;                                 //其他数据项
}HashTable[m];
```

【算法步骤】

① 给定待查找的关键字key，根据造表时设定的散列函数计算H0=H(key)。

② 若单元H0为空，则所查元素不存在。

③ 若单元H0中元素的关键字为key，则查找成功。

④ 否则重复下述解决冲突的过程：

- 按处理冲突的方法，计算下一个散列地址Hi；
- 若单元Hi为空，则所查元素不存在；
- 若单元Hi中元素的关键字为key，则查找成功。

【算法描述】

```c++
#define NULLKEY 0                               //单元为空的标记
int SearchHash(HashTable HT,KeyType key)
{//在散列表HT中查找关键字为key的元素，若查找成功，返回散列表的单元标号，否则返回-1  
   H0=H(key);                                  //根据散列函数H（key）计算散列地址 
   if(HT[H0].key==NULLKEY) return -1;          //若单元H0为空，则所查元素不存在 
   else if(HT[H0].key==key) return H0;         //若单元H0中元素的关键字为key，则查找成功 
   else 
   { 
      for(i=1;i<m;++i) 
     {     
         Hi=(H0+i)%m;                          //按照线性探测法计算下一个散列地址Hi 
         if(HT[Hi].key==NULLKEY) return -1;    //若单元Hi为空，则所查元素不存在 
         else if(HT[Hi].key==key) return Hi;   //若单元Hi中元素的关键字为key，则查找成功 
      }                                        //for 
      return -1; 
    }                                          //else 
}
```

【算法分析】

> 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表查找效率的量度。

查找过程中需和给定值进行比较的关键字的个数取决于三个因素：**散列函数**、**处理冲突的方法**和**装填因子**。

散列表的**装填因子α**定义为:
$$
\alpha = \frac{表中填入的记录数}{散列表的长度}
$$
α标志散列表的装满程度。直观地看，α越小，发生冲突的可能性就越小；反之，α越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。

散列函数的“好坏”首先影响出现冲突的频繁程度。但一般情况下认为：凡是“均匀的”散列函数，对同一组随机的关键字，产生冲突的可能性相同，假如所设定的散列函数是“均匀”的，则影响平均查找长度的因素只有两个——处理冲突的方法和装填因子α。

下表给出了在等概率情况下，采用几种不同方法处理冲突时，得到的散列表查找成功和查找失败时的平均查找长度

![image-20241118212826868](.\images\image-20241118212826868.png)



在查找概率相等的前提下，直接计算查找成功的平均查找长度公式为：
$$
ASL_{succ} = \frac{1}{n} \sum_{i=1}^{n}C_i
$$
其中，n为散列表中记录的个数，Ci为成功查找第i个记录所需的比较次数。



在查找概率相等的前提下，直接计算查找失败的平均查找长度公式：
$$
ASL_{unsucc} = \frac{1}{r} \sum_{i=1}^{r}C_i
$$
其中，r为散列函数取值的个数，Ci为散列函数取值为i时查找失败的比较次数。

> 查找失败时有两种情况：
>
> - 单元为空；
> - 按处理冲突的方法探测一遍后仍未找到。假设散列函数的取值个数为r，则0到r−1相当于r个查找失败的入口，从每个入口进入后，直到确定查找失败为止(单元为空)，其关键字的比较次数就是与该入口对应的查找失败的查找长度。



## 小结

线性表的查找：顺序查找、折半查找和分块查找

![image-20241118214910540](.\images\image-20241118214910540.png)

树表的查找：树表的结构主要包括二叉排序树、平衡二叉树、B-树和B+树。

（1）二叉排序树的查找过程与折半查找过程类似

![image-20241118215148864](.\images\image-20241118215148864.png)

（2）二叉排序树在形态均匀时性能最好，而形态为单支树时其查找性能则退化为与顺序查找相同，因此，二叉排序树最好是一棵平衡二叉树。平衡二叉树的平衡调整方法就是确保二叉排序树在任何情况下的深度均为O(log2n )，平衡调整方法分为4种：LL型、RR型、LR型和RL型。

（3） B-树是一种平衡的多叉查找树，是一种在外存文件系统中常用的动态索引技术。在B-树上进行查找的过程和二叉排序树类似，是一个顺指针查找结点和在结点内的关键字中查找交叉进行的过程。为了确保B-树的定义，在B-树中插入一个关键字，可能产生结点的“分裂”，而删除一个关键字，可能产生结点的“合并”。

（4）B+树是一种B-树的变型树，更适合做文件系统的索引。在B+树上进行随机查找、插入和删除的过程基本上与B-树类似，但具体实现细节又有所区别。



散列表的查找。散列表也属线性结构，但它和线性表的查找有着本质的区别。它不是以关键字比较为基础进行查找的，而是通过一种散列函数把记录的关键字和它在表中的位置建立起对应关系，并在存储记录发生冲突时采用专门的处理冲突的方法。这种方式构造的散列表，不仅平均查找长度和记录总数无关，而且可以通过调节装填因子，把平均查找长度控制在所需的范围内。

散列查找法主要研究两方面的问题：如何构造散列函数，以及如何处理冲突。

![image-20241118215640519](.\images\image-20241118215640519.png)
