

# 查找



## 查找的基本概念

**查找表**：查找表是由同一类型的数据元素（或记录）构成的集合。

**关键字**：关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字**（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

**查找**：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找成功**，此时查找的结果可给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功，**此时查找的结果可给出一个“空”记录或“空”指针。

**动态查找表和静态查找表**：若在查找的同时对表做修改操作（如插入和删除），则相应的表称之为动态**查找表**，否则称之为**静态查找表**。

> 换句话说，动态查找表的表结构本身是在查找过程中动态生成的，即在创建表时，对于给定值，若表中存在其关键字等于给定值的记录，则查找成功返回；否则插入关键字等于给定值的记录。

**平均查找长度**：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length，ASL）。

对于含有n个记录的表，查找成功时的平均查找长度为
$$
ASL = \sum_{i=1}^{n}{p_ic_i} \\
And\ \ \sum_{i=1}^{n}p_i = 1
$$
其中，Pi为查找表中第i个记录的概率；Ci为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。显然，Ci随查找过程不同而不同。

> 由于查找算法的基本运算是关键字之间的比较操作，所以可用平均查找长度来衡量查找算法的性能。



## 线性表的查找



### 顺序查找

**顺序查找**（Sequential Search）的查找过程为：从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。

```c++
int Search_Seq(SSTable ST,KeyType key)
{//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0
   ST.R[0].key=key;                                             //“哨兵”
   for(i=ST.length;ST.R[i].key!=key;--i);                       //从后往前找
   return i;
}
```

**算法分析**：

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i} = \frac{n+1}{2}
$$
**时间复杂度**：O(n)。

**顺序查找的优点**：算法简单，对表结构无任何要求，既适用于顺序结构，也适用于链式结构，无论记录是否按关键字有序均可应用。

**顺序查找的缺点**：平均查找长度较大，查找效率较低，所以当n很大时，不宜采用顺序查找。



### 折半查找

**折半查找**（Binary Search）的查找过程为：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果给定值大于或者小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

```c++
int Search_Bin(SSTable ST,KeyType key)
{//在有序表ST中折半查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0 
   low=1;high=ST.length;                       //置查找区间初值 
   while(low<=high) 
   { 
      mid=(low+high)/2; 
      if(key==ST.R[mid].key) return mid;       //找到待查元素 
      else if(key<ST.R[mid].key) high=mid-1;   //继续在前一子表进行查找 
      else low=mid+1;                          //继续在后一子表进行查找 
   }                                           //while 
   return 0;                                   //表中不存在待查元素 
}
```

> 注意：循环执行的条件是low<=high，而不是low<high，因为low=high时，查找区间还有最后一个结点，还要进一步比较。

**算法分析**：

折半查找过程可用二叉树来描述。树中每一结点对应表中一个记录，但结点值不是记录的关键字，而是记录在表中的位置序号。把当前查找区间的中间位置作为根，左子表和右子表分别作为根的左子树和右子树，由此得到的二叉树称为折半查找的**判定树**。

折半查找法在查找成功时进行比较的关键字个数最多不超过树的深度。而判定树的形态只与表记录个数n相关，而与关键字的取值无关，具有n个结点的判定树的深度为$$\lfloor log_{2}{n} \rfloor + 1$$。

**查找成功时的平均查找长度**:
$$
ASL_{成功} = \frac{1}{n} \sum_{i=1}^{n}{i \cdot 2^{i-1}} = \frac{n+1}{n} log_{2}{(n+1)} - 1 \\
n较大时,\ \ \ ASL_{成功} = log_{2}{(n+1)} - 1
$$
**时间复杂度**：O(log2n )。

**折半查找的优点**：比较次数少，查找效率高。

**折半查找的缺点**：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。



### 分块查找

**分块查找**（Blocking Search）又称**索引顺序查找**